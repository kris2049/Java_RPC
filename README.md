## 第一阶段：构建简单 RPC 调用框架

### 目标

本阶段致力于打造一个基础的 RPC（远程过程调用）调用系统。通过设计简洁的架构与清晰的执行流程，实现客户端与服务端之间的远程方法调用，为后续系统的功能扩展与优化奠定坚实基础。

### 核心实现步骤

1. 数据结构定义

明确定义 RpcRequest 和 RpcResponse 数据结构。这两个结构作为客户端与服务端数据交互的标准模型，确保数据在传输和解析过程中的准确性与一致性，为高效的数据通信提供保障。

2. 客户端动态代理实现

采用动态代理技术为客户端创建调用接口。客户端借助代理对象发起远程方法调用，无需关注底层复杂的网络通信细节，显著提高开发效率和代码的可维护性，使开发人员能够更专注于业务逻辑的实现。

3. 序列化工具选择

选用 Protobuf 作为唯一的序列化工具。Protobuf 以其出色的数据压缩能力和高效的传输性能，确保数据在网络中的快速、准确传输，有效减少网络带宽占用和传输延迟。

4. 网络通信方式

采用传统的 BIO（Blocking I/O）网络通信模式。该模式为系统提供了稳定可靠的通信基础，确保数据传输的完整性和准确性，尤其适用于对数据准确性要求较高的场景。

5. 服务注册机制

服务端利用哈希表作为服务注册表。在服务器启动时，将服务实现类实例注册到该表中，实现服务的集中管理和快速查找，提高服务调用的响应速度。

### 整体流程详解

#### 服务端流程

初始化序列器：加载 Protobuf 序列化工具，为后续数据的序列化和反序列化操作做好准备，确保数据能够正确地在网络中传输和解析。

创建服务端实例：启动服务端并监听指定端口，时刻准备接收客户端的连接请求，为客户端提供服务。

创建服务实现类实例：实例化具体的服务实现类，这些实例将提供实际的业务逻辑，满足客户端的远程调用需求。

注册服务：将服务实现类实例注册到服务注册表中，通过类名建立映射关系，方便后续快速定位和调用服务。

启动服务端监听端口：开始监听客户端请求，进入服务状态，随时准备处理客户端的远程调用请求。

#### 客户端流程

初始化序列器：同样加载 Protobuf 序列化工具，保证客户端与服务端使用相同的序列化方式，确保数据在传输过程中的兼容性和一致性。

创建客户端代理实例：生成客户端代理对象，该对象封装了远程调用的网络通信逻辑，使客户端能够以本地调用的方式发起远程请求。

获取服务接口的代理对象：通过代理实例获取服务接口的代理对象，为后续调用远程方法提供便捷的接口。

调用远程方法：客户端通过代理对象发起远程方法调用，触发整个 RPC 调用流程。

#### 代理对象内部流程

创建 RpcRequest 对象：封装调用的方法名、参数等必要信息，构建完整的请求对象，准确传达客户端的调用意图。

序列化请求对象：使用 Protobuf 序列化工具将请求对象转换为字节流，以便在网络中进行传输。

发送请求并接收响应：通过网络将序列化后的请求发送到服务端，并等待服务端的响应，确保数据的可靠传输。

反序列化响应对象：将接收到的响应字节流反序列化为 RpcResponse 对象，提取响应数据，为客户端提供可处理的结果。

返回响应结果：将反序列化后的响应结果返回给客户端调用者，完成整个远程调用过程。

#### 服务端响应流程

接收请求：监听客户端请求，获取客户端发送的序列化请求数据，确保数据的准确接收。

将请求反序列化：使用 Protobuf 序列化工具将请求字节流反序列化为 RpcRequest 对象，解析客户端的调用请求。

处理请求：根据请求中的方法名和参数，从服务注册表中查找对应的服务实例，并调用相应的方法，执行具体的业务逻辑。

将响应对象序列化：将方法调用的结果封装到 RpcResponse 对象中，并使用 Protobuf 序列化工具将其转换为字节流，为返回响应做准备。

发送响应给客户端：通过网络将序列化后的响应数据发送回客户端，完成服务端的响应过程。

#### 服务端处理请求流程

根据类名从映射表中获取服务实例：在服务注册表中查找与请求类名对应的服务实例，快速定位提供服务的对象。

根据方法名和参数类型获取方法对象：通过反射机制，根据请求中的方法名和参数类型获取具体的方法对象，为方法调用做准备。

通过 invoke 调用方法并获取结果：使用反射调用方法对象，执行具体的服务逻辑，并获取方法调用的结果。

将结果封装到响应体，返回：将方法调用的结果封装到 RpcResponse 对象中，准备发送给客户端，完成服务端的处理流程。

## 第二阶段：拓展序列化工具

### 目标

在第一阶段的基础上，考虑到 Protobuf 序列化工具在处理小尺寸数据时存在一定的局限性，本阶段将引入多种序列化工具。通过支持多样化的序列化方式，满足不同场景下的数据序列化需求，提升系统的灵活性和性能，使系统能够更好地适应各种复杂的业务场景。

### 实现思路

统一接口设计：对现有系统进行改造，设计统一的序列化接口。该接口为不同的序列化工具提供一致的调用方式，使得系统能够方便地集成和切换不同的序列化实现。

多种工具实现：实现多种序列化工具，如 Java 原生序列化、Hessian、JSON 等。每种工具都有其独特的特点和适用场景，通过提供多样化的选择，满足不同数据类型和业务需求。

动态选择机制：允许客户端和服务端在运行时动态选择合适的序列化工具。根据数据的大小、类型和业务场景，系统能够自动或手动选择最适合的序列化方式，提高数据传输效率和系统性能。

### 预期效果

性能优化：系统能够根据具体的数据特点和业务需求，灵活选择最合适的序列化工具，有效提高数据传输效率和系统性能，减少不必要的资源消耗。

扩展性增强：通过引入多种序列化工具，增强系统的可扩展性。方便后续引入更多的序列化工具，满足不断变化的业务需求，使系统能够更好地适应未来的发展和变化。

## 第三阶段： 自定义协议

当前网络传输基于tcp，直接传输请求。这样做缺乏安全性，而且会提升整体系统的复杂性。比如在消息体的头中包含关于序列化方式的定义，消息的类型是请求还是响应或者是心跳检测等。消息体可以降低系统的复杂性。

消息体的定义：

消息体分为请求头和请求体两大部分：

请求头：

· 校验  ：  用于安全校验

· 版本号：  保证请求和响应一致性

· 序列化：  告诉服务器和客户端如何解析数据

· 类型  ：  标识是请求还是响应，或者是心跳检测等

· 状态  ：  类似HTTP200状态码

请求体： 发送的消息内容

```
  8bit        8bit         8bit       8bit        8bit       64bit          32bit              
|---校验---|---版本号---|---序列化---|---类型---|---状态---|---请求id---|---请求数据长度---|---请求体(payload)---|
```
请求头总长17bytes。

创建编解码器(Encoder和Decoder)对自定义的消息体进行编解码
